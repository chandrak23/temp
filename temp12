@Injectable()
export class KafkaService {
    private producer: any;
    private consumer: any;
    private correlationId: string;
    private consumerInitialized: boolean = false; // Flag to check if consumer is already initialized

    constructor(private readonly dqService: DqService) {
        this.initializeKafkaProducer(); // Initializing the Kafka producer
        this.initializeKafkaConsumer(); // Initialize the Kafka consumer
    }

    // Initialize Kafka producer
    private async initializeKafkaProducer() {
        const client = await kafkaClient(loggingLevel.INFO); // Creating a Kafka client with logging level
        this.producer = await kafkaProducer(client); // Initializing Kafka producer
        getLogger().debug('FileUploadService: Kafka Producer initialized'); // Logging successful initialization
    }

    // Initialize Kafka consumer
    async initializeKafkaConsumer() {
        if (this.consumerInitialized) return; // Prevent re-initialization of the consumer

        const client = await kafkaClient(loggingLevel.INFO); // Creating a Kafka client with logging level
        this.consumer = await kafkaConsumer(['NFR71304.DQ.Breach.Upload.Response'], client, [], {
            autoCommit: true // Enable auto-commit for message offsets
        });

        // Listen for messages
        this.consumer.on('message', async (message) => {
            console.log('**** kafkaresponse', message); // Logging the received message
            getLogger().debug(`FileUploadService: Received message from Kafka: ${JSON.stringify(message)}`); // Logging received message details
            const parsedMessage = JSON.parse(message.value.toString()); // Parsing the message value
            console.log('**** parsedkafkaresponse', parsedMessage); // Logging parsed response

            // Handle the response (e.g., save to DB, send to another service, etc.)
        });

        this.consumerInitialized = true; // Set the flag to indicate consumer is initialized
        getLogger().debug('FileUploadService: Kafka Consumer initialized and listening to response-topic'); // Logging successful initialization of the consumer
    }

    async consume(topic: string, correlationId: string) {
        // Avoid initializing the consumer again here; it should only be done in initializeKafkaConsumer
        return new Promise((resolve, reject) => {
            this.consumer.on('message', async ({ topic, partition, message }) => {
                const parsedMessage = message.value.toString(); // Converting message value to string
                const msgKey = message.key.toString(); // Getting message key

                console.log(`*** key: ${msgKey}, parsedMessage: ${parsedMessage}`); // Logging message key and parsed message

                // Check if the message key matches the correlationId
                if (msgKey === correlationId) {
                    resolve(JSON.parse(parsedMessage)); // Resolving the promise with parsed message
                }

                getLogger().debug(`FileUploadService: Received message from Kafka: ${JSON.stringify(parsedMessage)}`); // Logging the received message
            });
        });
    }

    // Function to handle file upload and Kafka message
    async uploadFile(file: any, breachuuid: string, nifiuuid: string): Promise<any> {
        try {
            // Simulating external file upload using Axios
            const uploadResponse: any = await this.dqService.uploadBlob(file); // Uploading the file and awaiting response
            console.log('*** uploadResponse', uploadResponse); // Logging upload response

            // On successful upload, get the uploaded file path
            const uploadedFilePath = uploadResponse.data.blobURIs; // Extracting uploaded file path
            const correlationId = Math.random().toString(36).substr(2, 9); // Generating a random correlation ID

            // Send the uploaded file path along with breachuuid and nifiuuid to Kafka topic
            await this.produceKafkaMessage('NFR71304.DQ.Breach.Upload.Request', uploadedFilePath, breachuuid, nifiuuid, correlationId); // Sending message to Kafka

            // Get the response
            const response = await this.consume('NFR71304.DQ.Breach.Upload.Response', correlationId); // Consuming response from Kafka
            return response; // Return the response
        } catch (err) {
            getLogger().error(`FileUploadService: Error uploading file: ${err.message}`); // Logging error during upload
            throw err; // Throwing the error to be handled upstream
        }
    }

    // Produce Kafka message with upload path, breachuuid, and nifiuuid
    private async produceKafkaMessage(topic: string, filePath: string, breachuuid: string, nifiuuid: string, correlationId: string) {
        try {
            // Construct message payload
            const payload = {
                updatedfile: filePath, // The path of the uploaded file
                breachuuid: 'BRCH_BANA_MISSINGGRANTOR', // Breach UUID
                nifiuuid: '3bc85a07-2e7c-48F3-8c28-cd537ab1b911', // Nifi UUID
            };

            console.log('*** correlationId', correlationId); // Logging correlation ID
            console.log('*** payload', payload); // Logging payload being sent

            // Send message to Kafka
            await this.producer.send({
                topic, // Topic to send message to
                messages: [{ value: JSON.stringify(payload), key: correlationId }], // Message payload and key
            }, (err, data) => {
                if (err) {
                    getLogger().error(`FileUploadService: Error sending message to Kafka: ${err.message}`); // Logging error if sending fails
                } else {
                    getLogger().debug(`FileUploadService: Successfully sent message to Kafka topic: ${JSON.stringify(data)}`); // Logging successful send
                }
            });
        } catch (err) {
            getLogger().error(`outer FileUploadService: Error sending message to Kafka: ${err.message}`); // Logging error during sending
        }
    }
}
